diff --git a/config/schema/linkit.schema.yml b/config/schema/linkit.schema.yml
index d5e45e7f337b0f338a225b8cb5654f71a04996a1..f9eef21c4b3dd957c9b5c19be1f0500e61862a2d 100644
--- a/config/schema/linkit.schema.yml
+++ b/config/schema/linkit.schema.yml
@@ -113,6 +113,27 @@ ckeditor.plugin.drupallink:
       type: string
       label: 'Linkit profile'
 
+# Schema for the Linkit widget.
+field.widget.settings.linkit:
+  type: field.widget.settings.link_default
+  label: 'Linkit widget settings'
+  mapping:
+    linkit_profile:
+      type: string
+      label: 'Linkit profile'
+    linkit_auto_link_text:
+      type: boolean
+      label: 'Automatically populate link text from entity label'
+
+# Schema for the Linkit formatter.
+field.formatter.settings.linkit:
+  type: field.formatter.settings.link
+  label: 'Linkit format settings'
+  mapping:
+    linkit_profile:
+      type: string
+      label: 'Linkit profile'
+
 ckeditor5.plugin.linkit_extension:
   type: mapping
   label: Linkit
diff --git a/js/linkit.autocomplete.js b/js/linkit.autocomplete.js
index 1416cff29d5b624f9214787219f44d3a1084a61b..648a8e8abbd32bbc246ad9f1f6eb288147844e5f 100644
--- a/js/linkit.autocomplete.js
+++ b/js/linkit.autocomplete.js
@@ -63,21 +63,36 @@
    *   False to prevent further handlers.
    */
   function selectHandler(event, ui) {
-    var $form = $(event.target).closest('form');
+    var $context = $(event.target).closest('form,fieldset,tr');
+
     if (!ui.item.path) {
       throw 'Missing path param.' + JSON.stringify(ui.item);
     }
 
-    $('input[name="href_dirty_check"]', $form).val(ui.item.path);
+    $('input[name="href_dirty_check"]', $context).val(ui.item.path);
 
     if (ui.item.entity_type_id || ui.item.entity_uuid || ui.item.substitution_id) {
       if (!ui.item.entity_type_id || !ui.item.entity_uuid || !ui.item.substitution_id) {
         throw 'Missing path param.' + JSON.stringify(ui.item);
       }
-
-      $('input[name="attributes[data-entity-type]"]', $form).val(ui.item.entity_type_id);
-      $('input[name="attributes[data-entity-uuid]"]', $form).val(ui.item.entity_uuid);
-      $('input[name="attributes[data-entity-substitution]"]', $form).val(ui.item.substitution_id);
+    }
+    $('input[name="attributes[href]"], input[name$="[attributes][href]"]', $context).val(ui.item.path);
+    $('input[name="attributes[data-entity-type]"], input[name$="[attributes][data-entity-type]"]', $context).val(ui.item.entity_type_id);
+    $('input[name="attributes[data-entity-uuid]"], input[name$="[attributes][data-entity-uuid]"]', $context).val(ui.item.entity_uuid);
+    $('input[name="attributes[data-entity-substitution]"], input[name$="[attributes][data-entity-substitution]"]', $context).val(ui.item.substitution_id);
+
+    if (ui.item.label) {
+      // Automatically set the link title.
+      var $linkTitle = $('*[data-linkit-widget-title-autofill-enabled]', $context);
+      if ($linkTitle.length > 0) {
+        if (!$linkTitle.val() || $linkTitle.hasClass('link-widget-title--auto')) {
+          // Set value to the label.
+          $linkTitle.val(ui.item.label);
+
+          // Flag title as being automatically set.
+          $linkTitle.addClass('link-widget-title--auto');
+        }
+      }
     }
 
     event.target.value = ui.item.path;
@@ -163,7 +178,7 @@
       // Act on textfields with the "form-linkit-autocomplete" class.
       var $autocomplete = $(once('linkit-autocomplete', 'input.form-linkit-autocomplete', context));
       if ($autocomplete.length) {
-        $.widget('custom.autocomplete', $.ui.autocomplete, {
+        $.widget('ui.autocomplete', $.ui.autocomplete, {
           _create: function () {
             this._super();
             this.widget().menu('option', 'items', '> :not(.linkit-result-line--group)');
@@ -172,19 +187,38 @@
           _renderItem: autocomplete.options.renderItem
         });
 
-        // Use jQuery UI Autocomplete on the textfield.
-        $autocomplete.autocomplete(autocomplete.options);
-        $autocomplete.autocomplete('widget').addClass('linkit-ui-autocomplete');
-
-        $autocomplete.click(function () {
-          $autocomplete.autocomplete('search', $autocomplete.val());
-        });
-
-        $autocomplete.on('compositionstart.autocomplete', function () {
-          autocomplete.options.isComposing = true;
-        });
-        $autocomplete.on('compositionend.autocomplete', function () {
-          autocomplete.options.isComposing = false;
+        // Process each item.
+        $autocomplete.each(function () {
+          var $uri = $(this);
+
+          // Use jQuery UI Autocomplete on the textfield.
+          $uri.autocomplete(autocomplete.options);
+          $uri.autocomplete('widget').addClass('linkit-ui-autocomplete');
+
+          $uri.click(function () {
+            $uri.autocomplete('search', $uri.val());
+          });
+
+          $uri.on('compositionstart.autocomplete', function () {
+            autocomplete.options.isComposing = true;
+          });
+          $uri.on('compositionend.autocomplete', function () {
+            autocomplete.options.isComposing = false;
+          });
+
+          $uri.closest('.form-item').siblings('.form-type-textfield').find('.linkit-widget-title')
+            .each(function() {
+              // Set automatic title flag if title is the same as uri text.
+              var $title  = $(this);
+              var uriValue = $uri.val();
+              if (uriValue && uriValue === $title.val()) {
+                $title.addClass('link-widget-title--auto');
+              }
+            })
+            .change(function () {
+              // Remove automatic title flag.
+              $(this).removeClass('link-widget-title--auto');
+            });
         });
       }
     },
diff --git a/src/Entity/Profile.php b/src/Entity/Profile.php
index 48cb5d12fc6cf3b239cdc4d839764a626c95eb33..ee31f47547830a47733ebdabae79e12c2b741b7b 100644
--- a/src/Entity/Profile.php
+++ b/src/Entity/Profile.php
@@ -6,6 +6,7 @@ use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Entity\EntityWithPluginCollectionInterface;
 use Drupal\linkit\MatcherCollection;
 use Drupal\linkit\MatcherInterface;
+use Drupal\linkit\Plugin\Linkit\Matcher\EntityMatcher;
 use Drupal\linkit\ProfileInterface;
 
 /**
@@ -108,6 +109,19 @@ class Profile extends ConfigEntityBase implements ProfileInterface, EntityWithPl
     return $this->getMatchers()->get($instance_id);
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getMatcherByEntityType($entity_type_id) {
+    foreach ($this->getMatchers() as $matcher) {
+      if ($matcher instanceof EntityMatcher && $matcher->getPluginDefinition()['target_entity'] === $entity_type_id) {
+        return $matcher;
+      }
+    }
+
+    return NULL;
+  }
+
   /**
    * {@inheritdoc}
    */
diff --git a/src/Plugin/Field/FieldFormatter/LinkitFormatter.php b/src/Plugin/Field/FieldFormatter/LinkitFormatter.php
new file mode 100644
index 0000000000000000000000000000000000000000..a9c1cfb9100a02c30af498dc02e622bbe71a0f9c
--- /dev/null
+++ b/src/Plugin/Field/FieldFormatter/LinkitFormatter.php
@@ -0,0 +1,207 @@
+<?php
+
+namespace Drupal\linkit\Plugin\Field\FieldFormatter;
+
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Field\FieldDefinitionInterface;
+use Drupal\Core\Field\FieldItemListInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Path\PathValidatorInterface;
+use Drupal\Core\Render\BubbleableMetadata;
+use Drupal\link\LinkItemInterface;
+use Drupal\link\Plugin\Field\FieldFormatter\LinkFormatter;
+use Drupal\linkit\ProfileInterface;
+use Drupal\linkit\SubstitutionManagerInterface;
+use Drupal\linkit\Utility\LinkitHelper;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Plugin implementation of the 'linkit' formatter.
+ *
+ * @FieldFormatter(
+ *   id = "linkit",
+ *   label = @Translation("Linkit"),
+ *   field_types = {
+ *     "link"
+ *   }
+ * )
+ */
+class LinkitFormatter extends LinkFormatter {
+
+  /**
+   * The substitution manager.
+   *
+   * @var \Drupal\linkit\SubstitutionManagerInterface
+   */
+  protected $substitutionManager;
+
+  /**
+   * The linkit profile storage service.
+   *
+   * @var \Drupal\Core\Entity\EntityStorageInterface
+   */
+  protected $linkitProfileStorage;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $plugin_id,
+      $plugin_definition,
+      $configuration['field_definition'],
+      $configuration['settings'],
+      $configuration['label'],
+      $configuration['view_mode'],
+      $configuration['third_party_settings'],
+      $container->get('path.validator'),
+      $container->get('entity_type.manager'),
+      $container->get('plugin.manager.linkit.substitution')
+    );
+  }
+
+  /**
+   * Constructs a new LinkitFormatter.
+   *
+   * @param string $plugin_id
+   *   The plugin_id for the formatter.
+   * @param mixed $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
+   *   The definition of the field to which the formatter is associated.
+   * @param array $settings
+   *   The formatter settings.
+   * @param string $label
+   *   The formatter label display setting.
+   * @param string $view_mode
+   *   The view mode.
+   * @param array $third_party_settings
+   *   Third party settings.
+   * @param \Drupal\Core\Path\PathValidatorInterface $path_validator
+   *   The path validator service.
+   * @param \Drupal\linkit\SubstitutionManagerInterface $substitution_manager
+   *   The substitution manager.
+   */
+  public function __construct($plugin_id, $plugin_definition, FieldDefinitionInterface $field_definition, array $settings, $label, $view_mode, array $third_party_settings, PathValidatorInterface $path_validator, EntityTypeManagerInterface $entityTypeManager, SubstitutionManagerInterface $substitution_manager) {
+    parent::__construct($plugin_id, $plugin_definition, $field_definition, $settings, $label, $view_mode, $third_party_settings, $path_validator);
+
+    $this->substitutionManager = $substitution_manager;
+    $this->linkitProfileStorage = $entityTypeManager->getStorage('linkit_profile');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function defaultSettings() {
+    return [
+      'linkit_profile' => 'default',
+    ] + parent::defaultSettings();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function settingsForm(array $form, FormStateInterface $form_state) {
+    $elements = parent::settingsForm($form, $form_state);
+
+    $options = array_map(function ($linkit_profile) {
+      return $linkit_profile->label();
+    }, $this->linkitProfileStorage->loadMultiple());
+
+    $elements['linkit_profile'] = [
+      '#type' => 'select',
+      '#title' => $this->t('Linkit profile'),
+      '#description' => $this->t('Must be the same as the profile selected on the form display for this field.'),
+      '#options' => $options,
+      '#default_value' => $this->getSetting('linkit_profile'),
+    ];
+
+    return $elements;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function settingsSummary() {
+    $summary = parent::settingsSummary();
+
+    $linkit_profile_id = $this->getSetting('linkit_profile');
+    $linkit_profile = $this->linkitProfileStorage->load($linkit_profile_id);
+
+    if ($linkit_profile) {
+      $summary[] = $this->t('Linkit profile: @linkit_profile', ['@linkit_profile' => $linkit_profile->label()]);
+    }
+
+    return $summary;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function viewElements(FieldItemListInterface $items, $langcode) {
+    $elements = parent::viewElements($items, $langcode);
+
+    // Loop over the elements and substitute the URL.
+    foreach ($elements as $delta => &$item) {
+      /** @var \Drupal\link\LinkItemInterface $link_item */
+      $link_item = $items->get($delta);
+      $substituted_url = $this->getSubstitutedUrl($link_item);
+      // Convert generated URL into a URL object.
+      if ($substituted_url && ($url = $this->pathValidator->getUrlIfValid($substituted_url->getGeneratedUrl()))) {
+        // Keep query and fragment.
+        $parsed_url = parse_url($link_item->uri);
+        if (!empty($parsed_url['query'])) {
+          $parsed_query = [];
+          parse_str($parsed_url['query'], $parsed_query);
+          if (!empty($parsed_query)) {
+            $url->setOption('query', $parsed_query);
+          }
+        }
+        if (!empty($parsed_url['fragment'])) {
+          $url->setOption('fragment', $parsed_url['fragment']);
+        }
+        // Add cache dependency to the generated substituted URL.
+        $cacheable_metadata = BubbleableMetadata::createFromRenderArray($item)
+          ->addCacheableDependency($substituted_url);
+        // Add cache dependency to the referenced entity, e.g. for media direct
+        // file substitution.
+        if ($entity = LinkitHelper::getEntityFromUserInput($link_item->uri)) {
+          $cacheable_metadata->addCacheableDependency($entity);
+        }
+        $cacheable_metadata->applyTo($item);
+        $item['#url'] = $url;
+      }
+    }
+
+    return $elements;
+  }
+
+  /**
+   * Returns a substitution URL for the given linked item.
+   *
+   * In case the items links to an entity use a substituted/generated URL.
+   *
+   * @param \Drupal\link\LinkItemInterface $item
+   *   The link item.
+   *
+   * @return \Drupal\Core\GeneratedUrl|null
+   *   The substitution URL, or NULL if not able to retrieve it from the item.
+   */
+  protected function getSubstitutedUrl(LinkItemInterface $item) {
+    if ($entity = LinkitHelper::getEntityFromUserInput($item->uri)) {
+      $linkit_profile = $this->linkitProfileStorage->load($this->getSettings()['linkit_profile']);
+
+      if (!$linkit_profile instanceof ProfileInterface) {
+        return NULL;
+      }
+
+      /** @var \Drupal\linkit\Plugin\Linkit\Matcher\EntityMatcher $matcher */
+      $matcher = $linkit_profile->getMatcherByEntityType($entity->getEntityTypeId());
+      $substitution_type = $matcher ? $matcher->getConfiguration()['settings']['substitution_type'] : SubstitutionManagerInterface::DEFAULT_SUBSTITUTION;
+      return $this->substitutionManager->createInstance($substitution_type)->getUrl($entity);
+    }
+
+    return NULL;
+  }
+
+}
diff --git a/src/Plugin/Field/FieldWidget/LinkitWidget.php b/src/Plugin/Field/FieldWidget/LinkitWidget.php
new file mode 100644
index 0000000000000000000000000000000000000000..a5b28ea3c2cb644a50ccddb967592767b7806b15
--- /dev/null
+++ b/src/Plugin/Field/FieldWidget/LinkitWidget.php
@@ -0,0 +1,198 @@
+<?php
+
+namespace Drupal\linkit\Plugin\Field\FieldWidget;
+
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Field\FieldDefinitionInterface;
+use Drupal\Core\Field\FieldItemListInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Session\AccountProxyInterface;
+use Drupal\link\Plugin\Field\FieldWidget\LinkWidget;
+use Drupal\linkit\Utility\LinkitHelper;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Plugin implementation of the 'linkit' widget.
+ *
+ * @FieldWidget(
+ *   id = "linkit",
+ *   label = @Translation("Linkit"),
+ *   field_types = {
+ *     "link"
+ *   }
+ * )
+ */
+class LinkitWidget extends LinkWidget {
+
+  /**
+   * The current user.
+   *
+   * @var \Drupal\Core\Session\AccountProxyInterface
+   */
+  protected $currentUser;
+
+  /**
+   * The linkit profile storage service.
+   *
+   * @var \Drupal\Core\Entity\EntityStorageInterface
+   */
+  protected $linkitProfileStorage;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $plugin_id,
+      $plugin_definition,
+      $configuration['field_definition'],
+      $configuration['settings'],
+      $configuration['third_party_settings'],
+      $container->get('current_user'),
+      $container->get('entity_type.manager')
+    );
+  }
+
+  /**
+   * @param $plugin_id
+   *   The plugin_id for the formatter.
+   * @param mixed $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
+   *   The definition of the field to which the formatter is associated.
+   * @param array $settings
+   *   The widget settings.
+   * @param array $third_party_settings
+   *   The widget third party settings.
+   * @param \Drupal\Core\Session\AccountProxyInterface $currentUser
+   *   The current user.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entityTypeManager
+   *   The entity type manager service.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   */
+  public function __construct($plugin_id, $plugin_definition, FieldDefinitionInterface $field_definition, array $settings, array $third_party_settings, AccountProxyInterface $currentUser, EntityTypeManagerInterface $entityTypeManager) {
+    parent::__construct($plugin_id, $plugin_definition, $field_definition, $settings, $third_party_settings);
+    $this->currentUser = $currentUser;
+    $this->linkitProfileStorage = $entityTypeManager->getStorage('linkit_profile');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function defaultSettings() {
+    return [
+        'linkit_profile' => 'default',
+        'linkit_auto_link_text' => FALSE,
+      ] + parent::defaultSettings();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function settingsForm(array $form, FormStateInterface $form_state) {
+    $elements = parent::settingsForm($form, $form_state);
+
+    $options = array_map(function ($linkit_profile) {
+      return $linkit_profile->label();
+    }, $this->linkitProfileStorage->loadMultiple());
+
+    $elements['linkit_profile'] = [
+      '#type' => 'select',
+      '#title' => $this->t('Linkit profile'),
+      '#options' => $options,
+      '#default_value' => $this->getSetting('linkit_profile'),
+    ];
+    $elements['linkit_auto_link_text'] = [
+      '#type' => 'checkbox',
+      '#title' => $this->t('Automatically populate link text from entity label'),
+      '#default_value' => $this->getSetting('linkit_auto_link_text'),
+    ];
+
+    return $elements;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function settingsSummary() {
+    $summary = parent::settingsSummary();
+
+    $linkit_profile_id = $this->getSetting('linkit_profile');
+    $linkit_profile = $this->linkitProfileStorage->load($linkit_profile_id);
+
+    if ($linkit_profile) {
+      $summary[] = $this->t('Linkit profile: @linkit_profile', ['@linkit_profile' => $linkit_profile->label()]);
+    }
+
+    $auto_link_text = $this->getSetting('linkit_auto_link_text') ? $this->t('Yes') : $this->t('No');
+    $summary[] = $this->t(
+      'Automatically populate link text from entity label: @auto_link_text',
+      ['@auto_link_text' => $auto_link_text]
+    );
+
+    return $summary;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state) {
+    $element = parent::formElement($items, $delta, $element, $form, $form_state);
+
+    /** @var \Drupal\link\LinkItemInterface $item */
+    $item = $items[$delta];
+    $uri = $item->uri ?? NULL;
+
+    // Try to fetch entity information from the URI.
+    $default_allowed = !$item->isEmpty() && ($this->currentUser->hasPermission('link to any page') || $item->getUrl()->access());
+    $entity = $default_allowed && $uri ? LinkitHelper::getEntityFromUri($uri) : NULL;
+
+    // Change the URI field to use the linkit profile.
+    $element['uri']['#type'] = 'linkit';
+    $element['uri']['#description'] = $this->t('Start typing to find content or paste a URL and click on the suggestion below.');
+    $element['uri']['#autocomplete_route_name'] = 'linkit.autocomplete';
+    $element['uri']['#autocomplete_route_parameters'] = [
+      'linkit_profile_id' => $this->getSetting('linkit_profile'),
+    ];
+
+    // Add a class to the title field.
+    $element['title']['#attributes']['class'][] = 'linkit-widget-title';
+    if ($this->getSetting('linkit_auto_link_text')) {
+      $element['title']['#attributes']['data-linkit-widget-title-autofill-enabled'] = TRUE;
+    }
+
+    // Add linkit specific attributes.
+    $element['attributes']['href'] = [
+      '#type' => 'hidden',
+      '#default_value' => $default_allowed ? $uri : '',
+    ];
+    $element['attributes']['data-entity-type'] = [
+      '#type' => 'hidden',
+      '#default_value' => $entity ? $entity->getEntityTypeId() : '',
+    ];
+    $element['attributes']['data-entity-uuid'] = [
+      '#type' => 'hidden',
+      '#default_value' => $entity ? $entity->uuid() : '',
+    ];
+    $element['attributes']['data-entity-substitution'] = [
+      '#type' => 'hidden',
+      '#default_value' => $entity ? ($entity->getEntityTypeId() === 'file' ? 'file' : 'canonical') : '',
+    ];
+
+    return $element;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function massageFormValues(array $values, array $form, FormStateInterface $form_state) {
+    foreach ($values as &$value) {
+      $value['uri'] = LinkitHelper::uriFromUserInput($value['uri']);
+      $value += ['options' => []];
+    }
+    return $values;
+  }
+
+}
diff --git a/src/ProfileInterface.php b/src/ProfileInterface.php
index de8c5da84d476dccca5a8c58a0d0f5046ee1dafc..3d2e8cd0148d4a6cffdf2a3bffefed7a0c4323d7 100644
--- a/src/ProfileInterface.php
+++ b/src/ProfileInterface.php
@@ -38,6 +38,17 @@ interface ProfileInterface extends ConfigEntityInterface {
    */
   public function getMatcher($instance_id);
 
+  /**
+   * Returns the first enabled matcher for the given entity type ID.
+   *
+   * @param string $entity_type_id
+   *   The entity type ID.
+   *
+   * @return \Drupal\linkit\Plugin\Linkit\Matcher\EntityMatcher|null
+   *   An entity matcher instance or null if not found.
+   */
+  public function getMatcherByEntityType($entity_type_id);
+
   /**
    * Returns the matchers for this profile.
    *
diff --git a/src/Utility/LinkitHelper.php b/src/Utility/LinkitHelper.php
new file mode 100644
index 0000000000000000000000000000000000000000..a785de164e5d02bd5d1d9e5f839bf84604ef261b
--- /dev/null
+++ b/src/Utility/LinkitHelper.php
@@ -0,0 +1,224 @@
+<?php
+
+namespace Drupal\linkit\Utility;
+
+use Drupal\Component\Utility\UrlHelper;
+use Drupal\Core\Url;
+use Drupal\Core\Entity\EntityInterface;
+
+/**
+ * Provides helper to operate on URIs.
+ */
+class LinkitHelper {
+
+  /**
+   * Load the entity referenced by an entity scheme uri.
+   *
+   * @param string $uri
+   *   An internal uri string representing an entity path, such as
+   *   "entity:node/23".
+   *
+   * @return \Drupal\Core\Entity\EntityInterface|null
+   *   The most appropriate translation of the entity that matches the given
+   *   uri, or NULL if could not match any entity.
+   */
+  public static function getEntityFromUri($uri) {
+    // Stripe out potential query and fragment from the uri.
+    $uri = strtok(strtok($uri, "?"), "#");
+    // Remove the schema, if any. Otherwise, remove the forwarding "/".
+    if (strpos($uri, 'entity:') !== FALSE) {
+      list(, $uri) = explode(':', $uri);
+    }
+    else {
+      $uri = trim($uri, '/');
+    }
+
+    if ($uri) {
+      $parts = explode('/', $uri, 2);
+      if (count($parts) === 2) {
+        list($entity_type, $entity_id) = $parts;
+        $entity_manager = \Drupal::entityTypeManager();
+        if ($entity_manager->hasDefinition($entity_type)) {
+          if ($entity = $entity_manager->getStorage($entity_type)->load($entity_id)) {
+            return \Drupal::service('entity.repository')->getTranslationFromContext($entity);
+          }
+        }
+      }
+    }
+
+    return NULL;
+  }
+
+  /**
+   * Returns a processed uri with a proper scheme (if applicable).
+   *
+   * Turns the internal links into uri strings.
+   *
+   * @param string $input
+   *   The raw (or processed) input.
+   *
+   * @return string|null
+   *   The uri string or null if the input is empty.
+   */
+  public static function uriFromUserInput($input) {
+    if (empty($input)) {
+      return NULL;
+    }
+
+    $host = parse_url($input, PHP_URL_HOST);
+    $scheme = parse_url($input, PHP_URL_SCHEME);
+
+    if ($scheme == 'mailto') {
+      return $input;
+    }
+
+    if ($host && UrlHelper::isExternal($input)) {
+      if (UrlHelper::externalIsLocal($input, \Drupal::request()->getSchemeAndHttpHost())) {
+        // The link points to this domain. Make it relative to perform an entity
+        // lookup.
+        $host_end = strpos($input, $host) + strlen($host);
+        $input = substr($input, $host_end);
+      }
+      else {
+        // This link is really external.
+        return $input;
+      }
+    }
+
+    // Make sure the URI starts with a slash, otherwise the Url's factory
+    // methods will throw exceptions.
+    $starts_with_hash = strpos($input, '#') === 0;
+    $starts_with_a_slash = strpos($input, '/') === 0;
+    $is_front = substr($input, 0, 7) === '<front>';
+    $is_nolink = substr($input, 0, 14) === 'route:<nolink>';
+    if (!$scheme && !$is_front && !$is_nolink && !$starts_with_a_slash && !$starts_with_hash) {
+      $input = "/$input";
+    }
+    // - '<front>' -> '/'
+    // - '<front>#foo' -> '/#foo'
+    if ($is_front) {
+      $input = '/' . substr($input, strlen('<front>'));
+    }
+
+    $entity = self::getEntityFromUserInput($input);
+    if ($entity) {
+      return 'entity:' . $entity->getEntityTypeId() . '/' . $entity->id() . static::getQueryAndFragment($input);
+    }
+
+    // It's a relative link. If it's a file, store it as `base:`. Otherwise it's
+    // most likely internal.
+    $public_files_dir = \Drupal::service('stream_wrapper_manager')
+      ->getViaScheme('public')
+      ->getDirectoryPath();
+
+    if (!empty($public_files_dir) && strpos($input, "/$public_files_dir") === 0) {
+      return "base:$input";
+    }
+    $scheme = parse_url($input, PHP_URL_SCHEME);
+    // Check if the input already contains a scheme.
+    if (!empty($scheme)) {
+      return $input;
+    }
+
+    return "internal:$input";
+  }
+
+  /**
+   * Tries to convert an uri into an entity in multiple ways.
+   *
+   * @param string $input
+   *   A uri or a path.
+   *
+   * @return \Drupal\Core\Entity\EntityInterface|null
+   *   The entity if found, null otherwise.
+   */
+  public static function getEntityFromUserInput($input) {
+    $scheme = parse_url($input, PHP_URL_SCHEME);
+
+    // Check if it's an entity URI (e.g. entity:node/1).
+    if (($scheme === 'entity' || !$scheme) && ($entity = static::getEntityFromUri($input))) {
+      return $entity;
+    }
+
+    // If not, it can be a path pointing to an entity.
+    if (!$scheme) {
+      // Which can be hidden behind an alias in any of the site's languages.
+      $input = 'internal:' . static::getPathByAlias($input);
+    }
+
+    try {
+      $route_name = Url::fromUri($input)->getRouteName();
+      $params = array_filter(Url::fromUri($input)->getRouteParameters());
+      foreach ($params as $possibly_an_entity_type => $possibly_an_entity_id) {
+        // Return only the entity, if this is a canonical route.
+        if ($route_name === 'entity.' . $possibly_an_entity_type . '.canonical') {
+          $entity = \Drupal::entityTypeManager()
+            ->getStorage($possibly_an_entity_type)
+            ->load($possibly_an_entity_id);
+          if (!($entity instanceof EntityInterface)) {
+            return NULL;
+          }
+          return \Drupal::service('entity.repository')
+            ->getTranslationFromContext($entity);
+        }
+      }
+    }
+    catch (\Exception $e) {
+      // Or not.
+    }
+
+    return NULL;
+  }
+
+  /**
+   * Tries to translate the given raw url path into an internal one.
+   *
+   * @param string $input
+   *   Raw URL string consisting of a path and, optionally, query and fragment.
+   *
+   * @return string
+   *   The internal path if any matched. The input string otherwise.
+   */
+  public static function getPathByAlias($input) {
+    $config = \Drupal::config('language.negotiation');
+    /** @var \Drupal\path_alias\AliasManagerInterface $path_alias_manager */
+    $path_alias_manager = \Drupal::service('path_alias.manager');
+    /** @var \Drupal\Core\Language\LanguageManagerInterface $language_manager */
+    $language_manager = \Drupal::service('language_manager');
+
+    $input_path = parse_url($input, PHP_URL_PATH);
+    foreach ($language_manager->getLanguages() as $language) {
+      if ($prefix = $config->get('url.prefixes.' . $language->getId())) {
+        // Strip the language prefix.
+        $input_path = preg_replace("/^\/$prefix\//", '/', $input_path);
+      }
+      $path_resolved = $path_alias_manager->getPathByAlias($input_path, $language->getId());
+      if ($path_resolved !== $input_path) {
+        return $path_resolved . static::getQueryAndFragment($input);
+      }
+    }
+
+    return $input;
+  }
+
+  /**
+   * Returns the query and fragment part of a given URL string.
+   *
+   * @param string $input
+   *   An arbitrary URL.
+   *
+   * @return string
+   *   The query and fragment parts or an empty string.
+   */
+  public static function getQueryAndFragment($input) {
+    $result = '';
+    if ($query = parse_url($input, PHP_URL_QUERY)) {
+      $result .= "?$query";
+    }
+    if ($fragment = parse_url($input, PHP_URL_FRAGMENT)) {
+      $result .= "#$fragment";
+    }
+    return $result;
+  }
+
+}
diff --git a/tests/fixtures/update/drupal-8.linkit-enabled.standard.php.gz b/tests/fixtures/update/drupal-8.linkit-enabled.standard.php.gz
deleted file mode 100644
index 8d7de7fceda5f3600bcd623c221bde1322a97de6..0000000000000000000000000000000000000000
Binary files a/tests/fixtures/update/drupal-8.linkit-enabled.standard.php.gz and /dev/null differ
diff --git a/tests/src/FunctionalJavascript/LinkFieldTest.php b/tests/src/FunctionalJavascript/LinkFieldTest.php
new file mode 100644
index 0000000000000000000000000000000000000000..9ea0c18df9bf97df7c2fddb07d8ade97e167ad9b
--- /dev/null
+++ b/tests/src/FunctionalJavascript/LinkFieldTest.php
@@ -0,0 +1,368 @@
+<?php
+
+namespace Drupal\Tests\linkit\FunctionalJavascript;
+
+use Drupal\Component\Render\FormattableMarkup;
+use Drupal\Core\Url;
+use Drupal\entity_test\Entity\EntityTestMul;
+use Drupal\field\Entity\FieldConfig;
+use Drupal\field\Entity\FieldStorageConfig;
+use Drupal\FunctionalJavascriptTests\WebDriverTestBase;
+use Drupal\linkit\Tests\ProfileCreationTrait;
+use Drupal\node\Entity\NodeType;
+
+/**
+ * Tests the widget and formatter for Link fields.
+ *
+ * @group linkit
+ */
+class LinkFieldTest extends WebDriverTestBase {
+
+  use ProfileCreationTrait;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = [
+    'node',
+    'language',
+    'field_ui',
+    'entity_test',
+    'link',
+    'linkit',
+  ];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $defaultTheme = 'stark';
+
+  /**
+   * A linkit profile.
+   *
+   * @var \Drupal\linkit\ProfileInterface
+   */
+  protected $linkitProfile;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp(): void {
+    parent::setUp();
+
+    /** @var \Drupal\Core\Entity\EntityDisplayRepositoryInterface $entityDisplayRepository */
+    $entityDisplayRepository = $this->container->get('entity_display.repository');
+    $matcherManager = $this->container->get('plugin.manager.linkit.matcher');
+    /** @var \Drupal\linkit\MatcherInterface $plugin */
+
+    $this->linkitProfile = $this->createProfile();
+    $plugin = $matcherManager->createInstance('entity:entity_test_mul');
+    $this->linkitProfile->addMatcher($plugin->getConfiguration());
+    $plugin = $matcherManager->createInstance('email');
+    $this->linkitProfile->addMatcher($plugin->getConfiguration());
+    $plugin = $matcherManager->createInstance('front_page');
+    $this->linkitProfile->addMatcher($plugin->getConfiguration());
+    $this->linkitProfile->save();
+
+    // Create a node type for testing.
+    NodeType::create(['type' => 'page', 'name' => 'page'])->save();
+
+    // Create a link field.
+    $storage = FieldStorageConfig::create([
+      'field_name' => 'field_test_link',
+      'entity_type' => 'node',
+      'type' => 'link',
+    ]);
+    $storage->save();
+    FieldConfig::create([
+      'bundle' => 'page',
+      'entity_type' => 'node',
+      'field_name' => 'field_test_link',
+    ])->save();
+
+    // Define our widget and formatter for this field.
+    $this->container->get('entity_display.repository')->getFormDisplay('node', 'page', 'default')
+      ->setComponent('field_test_link', [
+        'type' => 'linkit',
+      ])
+      ->save();
+    $entityDisplayRepository->getViewDisplay('node', 'page', 'default')
+      ->setComponent('field_test_link', [
+        'type' => 'linkit',
+      ])
+      ->save();
+
+    $account = $this->drupalCreateUser([
+      'administer node fields',
+      'administer node display',
+      'administer nodes',
+      'bypass node access',
+      'view test entity',
+    ]);
+
+    $this->drupalLogin($account);
+  }
+
+  /**
+   * Test the "linkit" widget and formatter.
+   */
+  public function testLinkFieldWidgetAndFormatter() {
+    $session = $this->getSession();
+    $assert_session = $this->assertSession();
+    $page = $session->getPage();
+
+    // Create a test entity to be used as target.
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = EntityTestMul::create(['name' => 'Foo']);
+    $entity->save();
+
+    // Test the widget behavior.
+    $this->drupalGet('node/add/page');
+
+    $assert_session->elementContains('css', '#edit-field-test-link-wrapper', 'Start typing to find content or paste a URL and click on the suggestion below.');
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('f');
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+
+    // With the default profile no results are found.
+    $autocomplete_results_wrapper = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete');
+    $this->assertTrue($autocomplete_results_wrapper->isVisible());
+    $result_description = $assert_session->elementExists('css', 'li.linkit-result-line .linkit-result-line--description', $autocomplete_results_wrapper);
+    $this->assertEquals('No content suggestions found. This URL will be used as is.', $result_description->getText());
+
+    // Set the widget to use our profile and have autofill for link text
+    // enabled and try again.
+    $this->container->get('entity_display.repository')->getFormDisplay('node', 'page', 'default')
+      ->setComponent('field_test_link', [
+        'type' => 'linkit',
+        'settings' => [
+          'linkit_profile' => $this->linkitProfile->id(),
+          'linkit_auto_link_text' => TRUE,
+        ],
+      ])
+      ->save();
+    $this->drupalGet('node/add/page');
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('f');
+    $session->getDriver()->keyDown($uri_input->getXpath(), 'o');
+    $assert_session->waitOnAutocomplete();
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    // Check that the URL input field value shows the entity path.
+    $url_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $this->assertEquals($entity->toUrl()->toString(), $url_input->getValue());
+    // Check that the title was populated automatically.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $this->assertEquals('Foo', $title_input->getValue());
+
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 1');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 1 has been created');
+
+    // Check that we are viewing the node, and the formatter displays what we
+    // expect.
+    $assert_session->linkByHrefExists("/entity_test_mul/manage/{$entity->id()}");
+    $assert_session->linkExists('Foo');
+
+    // Test internal entity targets with anchors.
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity2 = EntityTestMul::create(['name' => 'Anchored Entity']);
+    $entity2->save();
+
+    // Test the widget behavior.
+    $this->drupalGet('node/add/page');
+
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('Anchored');
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    // Check that the URL input field value shows the entity path.
+    $url_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $this->assertEquals($entity2->toUrl()->toString(), $url_input->getValue());
+    // Check that the title was populated automatically.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $this->assertEquals('Anchored Entity', $title_input->getValue());
+
+    // Add an anchor to the URL field.
+    $url_input->setValue($entity2->toUrl()->toString() . '#with-anchor');
+
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 2');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 2 has been created');
+
+    // Check that we are viewing the node, and the formatter displays what we
+    // expect.
+    $assert_session->linkByHrefExists("/entity_test_mul/manage/{$entity2->id()}#with-anchor");
+    $assert_session->linkExists('Anchored Entity');
+
+    // Test external URLs.
+    $this->drupalGet('node/add/page');
+
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('https://google.com#foobar');
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $autocomplete_results_wrapper = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete');
+    $this->assertTrue($autocomplete_results_wrapper->isVisible());
+    $result_description = $assert_session->elementExists('css', 'li.linkit-result-line .linkit-result-line--description', $autocomplete_results_wrapper);
+    $this->assertEquals('No content suggestions found. This URL will be used as is.', $result_description->getText());
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    // Set a manual value for the title.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $title_input->setValue('This is google');
+
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 3');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 3 has been created');
+
+    // Check that we are viewing the node, and the formatter displays what we
+    // expect.
+    $assert_session->linkByHrefExists('https://google.com#foobar');
+    $assert_session->linkExists('This is google');
+
+    // Test that it is possible to add just the anchor.
+    $this->drupalGet('node/add/page');
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('#foobar');
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $title_input->setValue('Just a fragment');
+    $page->fillField('title[0][value]', 'Host test node 3.5');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 3.5 has been created');
+    $assert_session->linkByHrefExists('#foobar');
+    $assert_session->linkExists('Just a fragment');
+
+    // Test emails.
+    $this->drupalGet('node/add/page');
+
+    $email = 'drupal@example.com';
+
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue($email);
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    $url_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $this->assertEquals('mailto:' . $email, $url_input->getValue());
+    // Check that the title was populated automatically.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $this->assertEquals((string) new FormattableMarkup('E-mail @email', ['@email' => $email]), $title_input->getValue());
+
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 4');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 4 has been created');
+
+    // Check that we are viewing the node, and the formatter displays what we
+    // expect.
+    $assert_session->linkByHrefExists('mailto:' . $email);
+    $assert_session->linkExists((string) new FormattableMarkup('E-mail @email', ['@email' => $email]));
+
+    // Test internal host.
+    $this->drupalGet('node/add/page');
+
+    $url = \Drupal::request()->getSchemeAndHttpHost() . '/node/1';
+
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue($url);
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    $url_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $this->assertEquals($url, $url_input->getValue());
+    // Check that the title was populated automatically.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $this->assertEquals($url, $title_input->getValue());
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 5');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 5 has been created');
+
+    // Check that we are viewing the node, and the formatter displays what we
+    // expect Should display the relative url without the host.
+    $assert_session->linkByHrefExists('/node/1');
+    $assert_session->linkExists($url);
+
+    // Test front page.
+    $this->drupalGet('node/add/page');
+
+    $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+    $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+    $uri_input->setValue('<front>');
+    $session->getDriver()->keyDown($uri_input->getXpath(), ' ');
+    $assert_session->waitOnAutocomplete();
+    $first_result = $assert_session->elementExists('css', 'ul.linkit-ui-autocomplete li.linkit-result-line span.linkit-result-line--title');
+    $first_result->click();
+    $assert_session->assertWaitOnAjaxRequest();
+
+    $url_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+
+    $this->assertEquals(Url::fromRoute('<front>')->toString(), $url_input->getValue());
+    // Check that the title was populated automatically.
+    $title_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][title]"]', $widget_wrapper);
+    $this->assertEquals('Front page', $title_input->getValue());
+
+    // Give the node a title and save the page.
+    $page->fillField('title[0][value]', 'Host test node 6');
+    $page->pressButton('Save');
+    $assert_session->pageTextContains('Host test node 6 has been created');
+
+    $assert_session->linkByHrefExists(Url::fromRoute('<front>')->toString());
+    $assert_session->linkExists('Front page');
+
+    // Test invalid input.
+    foreach (['foo:0123456', ':', '123:bar'] as $key => $invalid_string) {
+      $this->drupalGet('node/add/page');
+      $page->fillField('title[0][value]', 'Invalid string node ' . $key);
+      $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+      $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+      $uri_input->setValue($invalid_string);
+      $assert_session->assertWaitOnAjaxRequest();
+
+      $page->pressButton('Save');
+      $assert_session->pageTextContains("$invalid_string' is invalid.");
+    }
+
+    // Test valid ones.
+    foreach (['tel:0123456', 'irc:irc.freenode.net'] as $key => $invalid_string) {
+      $this->drupalGet('node/add/page');
+      $page->fillField('title[0][value]', 'Valid string node ' . $key);
+      $widget_wrapper = $assert_session->elementExists('css', '#edit-field-test-link-wrapper');
+      $uri_input = $assert_session->elementExists('css', 'input[name="field_test_link[0][uri]"]', $widget_wrapper);
+      $uri_input->setValue($invalid_string);
+      $assert_session->assertWaitOnAjaxRequest();
+
+      $page->pressButton('Save');
+      $assert_session->pageTextContains("page Valid string node $key has been created");
+    }
+  }
+
+}
diff --git a/tests/src/Kernel/LinkitEditorLinkDialogTest.php b/tests/src/Kernel/LinkitEditorLinkDialogTest.php
index 6c48b5811a3c2211d3d10d0ce77e8865cbbb5878..489a557feb3d1225cdc948f0c799efa2f925a53e 100644
--- a/tests/src/Kernel/LinkitEditorLinkDialogTest.php
+++ b/tests/src/Kernel/LinkitEditorLinkDialogTest.php
@@ -76,19 +76,15 @@ class LinkitEditorLinkDialogTest extends LinkitKernelTestBase {
     $format->save();
 
     // Set up editor.
-    $ckeditor = $this->container->get('plugin.manager.editor')->createInstance('ckeditor');
     $this->editor = Editor::create([
       'format' => 'filtered_html',
       'editor' => 'ckeditor',
     ]);
-    $this->editor->setSettings([
-      'plugins' => [
-        'drupallink' => [
-          'linkit_enabled' => TRUE,
-          'linkit_profile' => $this->linkitProfile->id(),
-        ],
-      ],
-    ] + $ckeditor->getDefaultSettings());
+    $this->editor->save();
+    $settings = $this->editor->getSettings();
+    $settings['plugins']['drupallink']['linkit_enabled'] = TRUE;
+    $settings['plugins']['drupallink']['linkit_profile'] = $this->linkitProfile->id();
+    $this->editor->setSettings($settings);
     $this->editor->save();
   }
 
